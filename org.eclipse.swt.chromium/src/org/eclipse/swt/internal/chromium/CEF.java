/* automatically generated by rust-bindgen */

package org.eclipse.swt.internal.chromium;

import static org.eclipse.swt.internal.chromium.CEFFactory.mapTypeForClosure;

import jnr.ffi.*;
import jnr.ffi.annotations.*;
import jnr.ffi.byref.*;
import org.eclipse.swt.internal.chromium.CEFFactory.cef_base_ref_counted_t;
import jnr.ffi.util.EnumMapper.IntegerEnum;

public class CEF {
  public static class cef_string_utf16_t extends Struct {
    static {
      mapTypeForClosure(cef_string_utf16_t.class);
    }

    public Pointer str = new Pointer();
    public UnsignedLong length = new UnsignedLong();
    public Function<dtor> dtor = function(dtor.class);

    public static interface dtor {
      @Delegate
      void invoke(jnr.ffi.Pointer str);
    }

    public cef_string_utf16_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }

  public static class cef_string_userfree_utf16_t extends cef_string_utf16_t {
    public cef_string_userfree_utf16_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }

  public static class cef_string_userfree_t extends cef_string_userfree_utf16_t {
    public cef_string_userfree_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }

  public static class cef_string_t extends cef_string_utf16_t {
    public cef_string_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }

  public enum cef_errorcode_t implements IntegerEnum {
    ERR_NONE(0),
    ERR_FAILED(-2),
    ERR_ABORTED(-3),
    ERR_INVALID_ARGUMENT(-4),
    ERR_INVALID_HANDLE(-5),
    ERR_FILE_NOT_FOUND(-6),
    ERR_TIMED_OUT(-7),
    ERR_FILE_TOO_BIG(-8),
    ERR_UNEXPECTED(-9),
    ERR_ACCESS_DENIED(-10),
    ERR_NOT_IMPLEMENTED(-11),
    ERR_CONNECTION_CLOSED(-100),
    ERR_CONNECTION_RESET(-101),
    ERR_CONNECTION_REFUSED(-102),
    ERR_CONNECTION_ABORTED(-103),
    ERR_CONNECTION_FAILED(-104),
    ERR_NAME_NOT_RESOLVED(-105),
    ERR_INTERNET_DISCONNECTED(-106),
    ERR_SSL_PROTOCOL_ERROR(-107),
    ERR_ADDRESS_INVALID(-108),
    ERR_ADDRESS_UNREACHABLE(-109),
    ERR_SSL_CLIENT_AUTH_CERT_NEEDED(-110),
    ERR_TUNNEL_CONNECTION_FAILED(-111),
    ERR_NO_SSL_VERSIONS_ENABLED(-112),
    ERR_SSL_VERSION_OR_CIPHER_MISMATCH(-113),
    ERR_SSL_RENEGOTIATION_REQUESTED(-114),
    ERR_CERT_COMMON_NAME_INVALID(-200),
    ERR_CERT_BEGIN(-200),
    ERR_CERT_DATE_INVALID(-201),
    ERR_CERT_AUTHORITY_INVALID(-202),
    ERR_CERT_CONTAINS_ERRORS(-203),
    ERR_CERT_NO_REVOCATION_MECHANISM(-204),
    ERR_CERT_UNABLE_TO_CHECK_REVOCATION(-205),
    ERR_CERT_REVOKED(-206),
    ERR_CERT_INVALID(-207),
    ERR_CERT_WEAK_SIGNATURE_ALGORITHM(-208),
    ERR_CERT_NON_UNIQUE_NAME(-210),
    ERR_CERT_WEAK_KEY(-211),
    ERR_CERT_NAME_CONSTRAINT_VIOLATION(-212),
    ERR_CERT_VALIDITY_TOO_LONG(-213),
    ERR_CERT_END(-213),
    ERR_INVALID_URL(-300),
    ERR_DISALLOWED_URL_SCHEME(-301),
    ERR_UNKNOWN_URL_SCHEME(-302),
    ERR_TOO_MANY_REDIRECTS(-310),
    ERR_UNSAFE_REDIRECT(-311),
    ERR_UNSAFE_PORT(-312),
    ERR_INVALID_RESPONSE(-320),
    ERR_INVALID_CHUNKED_ENCODING(-321),
    ERR_METHOD_NOT_SUPPORTED(-322),
    ERR_UNEXPECTED_PROXY_AUTH(-323),
    ERR_EMPTY_RESPONSE(-324),
    ERR_RESPONSE_HEADERS_TOO_BIG(-325),
    ERR_CACHE_MISS(-400),
    ERR_INSECURE_RESPONSE(-501),
    ;
    private int nativeInt;

    private cef_errorcode_t(int nativeInt) {
      this.nativeInt = nativeInt;
    }

    @Override
    public int intValue() {
      return nativeInt;
    }
  }

  public enum cef_window_open_disposition_t implements IntegerEnum {
    WOD_UNKNOWN(0),
    WOD_CURRENT_TAB(1),
    WOD_SINGLETON_TAB(2),
    WOD_NEW_FOREGROUND_TAB(3),
    WOD_NEW_BACKGROUND_TAB(4),
    WOD_NEW_POPUP(5),
    WOD_NEW_WINDOW(6),
    WOD_SAVE_TO_DISK(7),
    WOD_OFF_THE_RECORD(8),
    WOD_IGNORE_ACTION(9),
    ;
    private int nativeInt;

    private cef_window_open_disposition_t(int nativeInt) {
      this.nativeInt = nativeInt;
    }

    @Override
    public int intValue() {
      return nativeInt;
    }
  }

  public enum cef_transition_type_t implements IntegerEnum {
    TT_LINK(0x0),
    TT_EXPLICIT(0x1),
    TT_AUTO_SUBFRAME(0x3),
    TT_MANUAL_SUBFRAME(0x4),
    TT_FORM_SUBMIT(0x7),
    TT_RELOAD(0x8),
    TT_SOURCE_MASK(0xff),
    TT_BLOCKED_FLAG(0x800000),
    TT_FORWARD_BACK_FLAG(0x1000000),
    TT_CHAIN_START_FLAG(0x10000000),
    TT_CHAIN_END_FLAG(0x20000000),
    TT_CLIENT_REDIRECT_FLAG(0x40000000),
    TT_SERVER_REDIRECT_FLAG(0x80000000),
    TT_IS_REDIRECT_MASK(0xc0000000),
    TT_QUALIFIER_MASK(0xffffff00),
    ;
    private int nativeInt;

    private cef_transition_type_t(int nativeInt) {
      this.nativeInt = nativeInt;
    }

    @Override
    public int intValue() {
      return nativeInt;
    }
  }

  public enum cef_process_id_t implements IntegerEnum {
    PID_BROWSER(0),
    PID_RENDERER(1),
    ;
    private int nativeInt;

    private cef_process_id_t(int nativeInt) {
      this.nativeInt = nativeInt;
    }

    @Override
    public int intValue() {
      return nativeInt;
    }
  }

  public enum cef_focus_source_t implements IntegerEnum {
    FOCUS_SOURCE_NAVIGATION(0),
    FOCUS_SOURCE_SYSTEM(1),
    ;
    private int nativeInt;

    private cef_focus_source_t(int nativeInt) {
      this.nativeInt = nativeInt;
    }

    @Override
    public int intValue() {
      return nativeInt;
    }
  }
  ///
  /// Implement this structure to receive string values asynchronously.
  ///
  public static class cef_string_visitor_t extends Struct {
    static {
      mapTypeForClosure(cef_string_visitor_t.class);
    }
    ///
    /// Base structure.
    ///
    public cef_base_ref_counted_t base = inner(new cef_base_ref_counted_t(getRuntime()));
    ///
    /// Method that will be executed.
    ///
    public Function<visit> visit = function(visit.class);

    public static interface visit {
      @Delegate
      void invoke(cef_string_visitor_t self_, cef_string_t string);
    }

    public cef_string_visitor_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }
  ///
  /// Structure used to implement browser process callbacks. The functions of this
  /// structure will be called on the browser process main thread unless otherwise
  /// indicated.
  ///
  public static class cef_browser_process_handler_t extends Struct {
    static {
      mapTypeForClosure(cef_browser_process_handler_t.class);
    }
    ///
    /// Base structure.
    ///
    public cef_base_ref_counted_t base = inner(new cef_base_ref_counted_t(getRuntime()));
    ///
    /// Called on the browser process UI thread immediately after the CEF context
    /// has been initialized.
    ///
    public Function<on_context_initialized> on_context_initialized =
        function(on_context_initialized.class);
    ///
    /// Called before a child process is launched. Will be called on the browser
    /// process UI thread when launching a render process and on the browser
    /// process IO thread when launching a GPU or plugin process. Provides an
    /// opportunity to modify the child process command line. Do not keep a
    /// reference to |command_line| outside of this function.
    ///
    public Function<on_before_child_process_launch> on_before_child_process_launch =
        function(on_before_child_process_launch.class);
    ///
    /// Called on the browser process IO thread after the main thread has been
    /// created for a new render process. Provides an opportunity to specify extra
    /// information that will be passed to
    /// cef_render_process_handler_t::on_render_thread_created() in the render
    /// process. Do not keep a reference to |extra_info| outside of this function.
    ///
    public Function<on_render_process_thread_created> on_render_process_thread_created =
        function(on_render_process_thread_created.class);
    ///
    /// Return the handler for printing on Linux. If a print handler is not
    /// provided then printing will not be supported on the Linux platform.
    ///
    public Function<get_print_handler> get_print_handler = function(get_print_handler.class);
    ///
    /// Called from any thread when work has been scheduled for the browser process
    /// main (UI) thread. This callback is used in combination with CefSettings.
    /// external_message_pump and cef_do_message_loop_work() in cases where the CEF
    /// message loop must be integrated into an existing application message loop
    /// (see additional comments and warnings on CefDoMessageLoopWork). This
    /// callback should schedule a cef_do_message_loop_work() call to happen on the
    /// main (UI) thread. |delay_ms| is the requested delay in milliseconds. If
    /// |delay_ms| is <= 0 then the call should happen reasonably soon. If
    /// |delay_ms| is > 0 then the call should be scheduled to happen after the
    /// specified delay and any currently pending scheduled call should be
    /// cancelled.
    ///
    public Function<on_schedule_message_pump_work> on_schedule_message_pump_work =
        function(on_schedule_message_pump_work.class);

    public static interface on_context_initialized {
      @Delegate
      void invoke(cef_browser_process_handler_t self_);
    }

    public static interface on_before_child_process_launch {
      @Delegate
      void invoke(cef_browser_process_handler_t self_, jnr.ffi.Pointer command_line);
    }

    public static interface on_render_process_thread_created {
      @Delegate
      void invoke(cef_browser_process_handler_t self_, jnr.ffi.Pointer extra_info);
    }

    public static interface get_print_handler {
      @Delegate
      jnr.ffi.Pointer invoke(cef_browser_process_handler_t self_);
    }

    public static interface on_schedule_message_pump_work {
      @Delegate
      void invoke(cef_browser_process_handler_t self_, int delay_ms);
    }

    public cef_browser_process_handler_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }
  ///
  /// Implement this structure to handle events related to browser load status. The
  /// functions of this structure will be called on the browser process UI thread
  /// or render process main thread (TID_RENDERER).
  ///
  public static class cef_load_handler_t extends Struct {
    static {
      mapTypeForClosure(cef_load_handler_t.class);
    }
    ///
    /// Base structure.
    ///
    public cef_base_ref_counted_t base = inner(new cef_base_ref_counted_t(getRuntime()));
    ///
    /// Called when the loading state has changed. This callback will be executed
    /// twice -- once when loading is initiated either programmatically or by user
    /// action, and once when loading is terminated due to completion, cancellation
    /// of failure. It will be called before any calls to OnLoadStart and after all
    /// calls to OnLoadError and/or OnLoadEnd.
    ///
    public Function<on_loading_state_change> on_loading_state_change =
        function(on_loading_state_change.class);
    ///
    /// Called after a navigation has been committed and before the browser begins
    /// loading contents in the frame. The |frame| value will never be NULL -- call
    /// the is_main() function to check if this frame is the main frame.
    /// |transition_type| provides information about the source of the navigation
    /// and an accurate value is only available in the browser process. Multiple
    /// frames may be loading at the same time. Sub-frames may start or continue
    /// loading after the main frame load has ended. This function will not be
    /// called for same page navigations (fragments, history state, etc.) or for
    /// navigations that fail or are canceled before commit. For notification of
    /// overall browser load status use OnLoadingStateChange instead.
    ///
    public Function<on_load_start> on_load_start = function(on_load_start.class);
    ///
    /// Called when the browser is done loading a frame. The |frame| value will
    /// never be NULL -- call the is_main() function to check if this frame is the
    /// main frame. Multiple frames may be loading at the same time. Sub-frames may
    /// start or continue loading after the main frame load has ended. This
    /// function will not be called for same page navigations (fragments, history
    /// state, etc.) or for navigations that fail or are canceled before commit.
    /// For notification of overall browser load status use OnLoadingStateChange
    /// instead.
    ///
    public Function<on_load_end> on_load_end = function(on_load_end.class);
    ///
    /// Called when a navigation fails or is canceled. This function may be called
    /// by itself if before commit or in combination with OnLoadStart/OnLoadEnd if
    /// after commit. |errorCode| is the error code number, |errorText| is the
    /// error text and |failedUrl| is the URL that failed to load. See
    /// net\base\net_error_list.h for complete descriptions of the error codes.
    ///
    public Function<on_load_error> on_load_error = function(on_load_error.class);

    public static interface on_loading_state_change {
      @Delegate
      void invoke(
          cef_load_handler_t self_,
          jnr.ffi.Pointer browser,
          int isLoading,
          int canGoBack,
          int canGoForward);
    }

    public static interface on_load_start {
      @Delegate
      void invoke(
          cef_load_handler_t self_,
          jnr.ffi.Pointer browser,
          jnr.ffi.Pointer frame,
          cef_transition_type_t transition_type);
    }

    public static interface on_load_end {
      @Delegate
      void invoke(
          cef_load_handler_t self_,
          jnr.ffi.Pointer browser,
          jnr.ffi.Pointer frame,
          int httpStatusCode);
    }

    public static interface on_load_error {
      @Delegate
      void invoke(
          cef_load_handler_t self_,
          jnr.ffi.Pointer browser,
          jnr.ffi.Pointer frame,
          cef_errorcode_t errorCode,
          cef_string_t errorText,
          cef_string_t failedUrl);
    }

    public cef_load_handler_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }
  ///
  /// Implement this structure to provide handler implementations. Methods will be
  /// called by the process and/or thread indicated.
  ///
  public static class cef_app_t extends Struct {
    static {
      mapTypeForClosure(cef_app_t.class);
    }
    ///
    /// Base structure.
    ///
    public cef_base_ref_counted_t base = inner(new cef_base_ref_counted_t(getRuntime()));
    ///
    /// Provides an opportunity to view and/or modify command-line arguments before
    /// processing by CEF and Chromium. The |process_type| value will be NULL for
    /// the browser process. Do not keep a reference to the cef_command_line_t
    /// object passed to this function. The CefSettings.command_line_args_disabled
    /// value can be used to start with an NULL command-line object. Any values
    /// specified in CefSettings that equate to command-line arguments will be set
    /// before this function is called. Be cautious when using this function to
    /// modify command-line arguments for non-browser processes as this may result
    /// in undefined behavior including crashes.
    ///
    public Function<on_before_command_line_processing> on_before_command_line_processing =
        function(on_before_command_line_processing.class);
    ///
    /// Provides an opportunity to register custom schemes. Do not keep a reference
    /// to the |registrar| object. This function is called on the main thread for
    /// each process and the registered schemes should be the same across all
    /// processes.
    ///
    public Function<on_register_custom_schemes> on_register_custom_schemes =
        function(on_register_custom_schemes.class);
    ///
    /// Return the handler for resource bundle events. If
    /// CefSettings.pack_loading_disabled is true (1) a handler must be returned.
    /// If no handler is returned resources will be loaded from pack files. This
    /// function is called by the browser and render processes on multiple threads.
    ///
    public Function<get_resource_bundle_handler> get_resource_bundle_handler =
        function(get_resource_bundle_handler.class);
    ///
    /// Return the handler for functionality specific to the browser process. This
    /// function is called on multiple threads in the browser process.
    ///
    public Function<get_browser_process_handler> get_browser_process_handler =
        function(get_browser_process_handler.class);
    ///
    /// Return the handler for functionality specific to the render process. This
    /// function is called on the render process main thread.
    ///
    public Function<get_render_process_handler> get_render_process_handler =
        function(get_render_process_handler.class);

    public static interface on_before_command_line_processing {
      @Delegate
      void invoke(cef_app_t self_, cef_string_t process_type, jnr.ffi.Pointer command_line);
    }

    public static interface on_register_custom_schemes {
      @Delegate
      void invoke(cef_app_t self_, jnr.ffi.Pointer registrar);
    }

    public static interface get_resource_bundle_handler {
      @Delegate
      jnr.ffi.Pointer invoke(cef_app_t self_);
    }

    public static interface get_browser_process_handler {
      @Delegate
      cef_browser_process_handler_t invoke(cef_app_t self_);
    }

    public static interface get_render_process_handler {
      @Delegate
      jnr.ffi.Pointer invoke(cef_app_t self_);
    }

    public cef_app_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }
  ///
  /// Implement this structure to handle events related to browser display state.
  /// The functions of this structure will be called on the UI thread.
  ///
  public static class cef_display_handler_t extends Struct {
    static {
      mapTypeForClosure(cef_display_handler_t.class);
    }
    ///
    /// Base structure.
    ///
    public cef_base_ref_counted_t base = inner(new cef_base_ref_counted_t(getRuntime()));
    ///
    /// Called when a frame's address has changed.
    ///
    public Function<on_address_change> on_address_change = function(on_address_change.class);
    ///
    /// Called when the page title changes.
    ///
    public Function<on_title_change> on_title_change = function(on_title_change.class);
    ///
    /// Called when the page icon changes.
    ///
    public Function<on_favicon_urlchange> on_favicon_urlchange =
        function(on_favicon_urlchange.class);
    ///
    /// Called when web content in the page has toggled fullscreen mode. If
    /// |fullscreen| is true (1) the content will automatically be sized to fill
    /// the browser content area. If |fullscreen| is false (0) the content will
    /// automatically return to its original size and position. The client is
    /// responsible for resizing the browser if desired.
    ///
    public Function<on_fullscreen_mode_change> on_fullscreen_mode_change =
        function(on_fullscreen_mode_change.class);
    ///
    /// Called when the browser is about to display a tooltip. |text| contains the
    /// text that will be displayed in the tooltip. To handle the display of the
    /// tooltip yourself return true (1). Otherwise, you can optionally modify
    /// |text| and then return false (0) to allow the browser to display the
    /// tooltip. When window rendering is disabled the application is responsible
    /// for drawing tooltips and the return value is ignored.
    ///
    public Function<on_tooltip> on_tooltip = function(on_tooltip.class);
    ///
    /// Called when the browser receives a status message. |value| contains the
    /// text that will be displayed in the status message.
    ///
    public Function<on_status_message> on_status_message = function(on_status_message.class);
    ///
    /// Called to display a console message. Return true (1) to stop the message
    /// from being output to the console.
    ///
    public Function<on_console_message> on_console_message = function(on_console_message.class);

    public static interface on_address_change {
      @Delegate
      void invoke(
          cef_display_handler_t self_,
          jnr.ffi.Pointer browser,
          jnr.ffi.Pointer frame,
          cef_string_t url);
    }

    public static interface on_title_change {
      @Delegate
      void invoke(cef_display_handler_t self_, jnr.ffi.Pointer browser, cef_string_t title);
    }

    public static interface on_favicon_urlchange {
      @Delegate
      void invoke(cef_display_handler_t self_, jnr.ffi.Pointer browser, jnr.ffi.Pointer icon_urls);
    }

    public static interface on_fullscreen_mode_change {
      @Delegate
      void invoke(cef_display_handler_t self_, jnr.ffi.Pointer browser, int fullscreen);
    }

    public static interface on_tooltip {
      @Delegate
      int invoke(cef_display_handler_t self_, jnr.ffi.Pointer browser, cef_string_t text);
    }

    public static interface on_status_message {
      @Delegate
      void invoke(cef_display_handler_t self_, jnr.ffi.Pointer browser, cef_string_t value);
    }

    public static interface on_console_message {
      @Delegate
      int invoke(
          cef_display_handler_t self_,
          jnr.ffi.Pointer browser,
          cef_string_t message,
          cef_string_t source,
          int line);
    }

    public cef_display_handler_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }
  ///
  /// Implement this structure to handle events related to focus. The functions of
  /// this structure will be called on the UI thread.
  ///
  public static class cef_focus_handler_t extends Struct {
    static {
      mapTypeForClosure(cef_focus_handler_t.class);
    }
    ///
    /// Base structure.
    ///
    public cef_base_ref_counted_t base = inner(new cef_base_ref_counted_t(getRuntime()));
    ///
    /// Called when the browser component is about to loose focus. For instance, if
    /// focus was on the last HTML element and the user pressed the TAB key. |next|
    /// will be true (1) if the browser is giving focus to the next component and
    /// false (0) if the browser is giving focus to the previous component.
    ///
    public Function<on_take_focus> on_take_focus = function(on_take_focus.class);
    ///
    /// Called when the browser component is requesting focus. |source| indicates
    /// where the focus request is originating from. Return false (0) to allow the
    /// focus to be set or true (1) to cancel setting the focus.
    ///
    public Function<on_set_focus> on_set_focus = function(on_set_focus.class);
    ///
    /// Called when the browser component has received focus.
    ///
    public Function<on_got_focus> on_got_focus = function(on_got_focus.class);

    public static interface on_take_focus {
      @Delegate
      void invoke(cef_focus_handler_t self_, jnr.ffi.Pointer browser, int next);
    }

    public static interface on_set_focus {
      @Delegate
      int invoke(cef_focus_handler_t self_, jnr.ffi.Pointer browser, cef_focus_source_t source);
    }

    public static interface on_got_focus {
      @Delegate
      void invoke(cef_focus_handler_t self_, jnr.ffi.Pointer browser);
    }

    public cef_focus_handler_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }
  ///
  /// Implement this structure to handle events related to browser life span. The
  /// functions of this structure will be called on the UI thread unless otherwise
  /// indicated.
  ///
  public static class cef_life_span_handler_t extends Struct {
    static {
      mapTypeForClosure(cef_life_span_handler_t.class);
    }
    ///
    /// Base structure.
    ///
    public cef_base_ref_counted_t base = inner(new cef_base_ref_counted_t(getRuntime()));
    ///
    /// Called on the IO thread before a new popup browser is created. The
    /// |browser| and |frame| values represent the source of the popup request. The
    /// |target_url| and |target_frame_name| values indicate where the popup
    /// browser should navigate and may be NULL if not specified with the request.
    /// The |target_disposition| value indicates where the user intended to open
    /// the popup (e.g. current tab, new tab, etc). The |user_gesture| value will
    /// be true (1) if the popup was opened via explicit user gesture (e.g.
    /// clicking a link) or false (0) if the popup opened automatically (e.g. via
    /// the DomContentLoaded event). The |popupFeatures| structure contains
    /// additional information about the requested popup window. To allow creation
    /// of the popup browser optionally modify |windowInfo|, |client|, |settings|
    /// and |no_javascript_access| and return false (0). To cancel creation of the
    /// popup browser return true (1). The |client| and |settings| values will
    /// default to the source browser's values. If the |no_javascript_access| value
    /// is set to false (0) the new browser will not be scriptable and may not be
    /// hosted in the same renderer process as the source browser. Any
    /// modifications to |windowInfo| will be ignored if the parent browser is
    /// wrapped in a cef_browser_view_t. Popup browser creation will be canceled if
    /// the parent browser is destroyed before the popup browser creation completes
    /// (indicated by a call to OnAfterCreated for the popup browser).
    ///
    public Function<on_before_popup> on_before_popup = function(on_before_popup.class);
    ///
    /// Called after a new browser is created. This callback will be the first
    /// notification that references |browser|.
    ///
    public Function<on_after_created> on_after_created = function(on_after_created.class);
    ///
    /// Called when a browser has recieved a request to close. This may result
    /// directly from a call to cef_browser_host_t::*close_browser() or indirectly
    /// if the browser is parented to a top-level window created by CEF and the
    /// user attempts to close that window (by clicking the 'X', for example). The
    /// do_close() function will be called after the JavaScript 'onunload' event
    /// has been fired.
    ///
    /// An application should handle top-level owner window close notifications by
    /// calling cef_browser_host_t::try_close_browser() or
    /// cef_browser_host_t::CloseBrowser(false (0)) instead of allowing the window
    /// to close immediately (see the examples below). This gives CEF an
    /// opportunity to process the 'onbeforeunload' event and optionally cancel the
    /// close before do_close() is called.
    ///
    /// When windowed rendering is enabled CEF will internally create a window or
    /// view to host the browser. In that case returning false (0) from do_close()
    /// will send the standard close notification to the browser's top-level owner
    /// window (e.g. WM_CLOSE on Windows, performClose: on OS X, "delete_event" on
    /// Linux or cef_window_delegate_t::can_close() callback from Views). If the
    /// browser's host window/view has already been destroyed (via view hierarchy
    /// tear-down, for example) then do_close() will not be called for that browser
    /// since is no longer possible to cancel the close.
    ///
    /// When windowed rendering is disabled returning false (0) from do_close()
    /// will cause the browser object to be destroyed immediately.
    ///
    /// If the browser's top-level owner window requires a non-standard close
    /// notification then send that notification from do_close() and return true
    /// (1).
    ///
    /// The cef_life_span_handler_t::on_before_close() function will be called
    /// after do_close() (if do_close() is called) and immediately before the
    /// browser object is destroyed. The application should only exit after
    /// on_before_close() has been called for all existing browsers.
    ///
    /// The below examples describe what should happen during window close when the
    /// browser is parented to an application-provided top-level window.
    ///
    /// Example 1: Using cef_browser_host_t::try_close_browser(). This is
    /// recommended for clients using standard close handling and windows created
    /// on the browser process UI thread. 1.  User clicks the window close button
    /// which sends a close notification to
    /// the application's top-level window.
    /// 2.  Application's top-level window receives the close notification and
    /// calls TryCloseBrowser() (which internally calls CloseBrowser(false)).
    /// TryCloseBrowser() returns false so the client cancels the window close.
    /// 3.  JavaScript 'onbeforeunload' handler executes and shows the close
    /// confirmation dialog (which can be overridden via
    /// CefJSDialogHandler::OnBeforeUnloadDialog()).
    /// 4.  User approves the close. 5.  JavaScript 'onunload' handler executes. 6.
    /// CEF sends a close notification to the application's top-level window
    /// (because DoClose() returned false by default).
    /// 7.  Application's top-level window receives the close notification and
    /// calls TryCloseBrowser(). TryCloseBrowser() returns true so the client
    /// allows the window close.
    /// 8.  Application's top-level window is destroyed. 9.  Application's
    /// on_before_close() handler is called and the browser object
    /// is destroyed.
    /// 10. Application exits by calling cef_quit_message_loop() if no other
    /// browsers
    /// exist.
    ///
    /// Example 2: Using cef_browser_host_t::CloseBrowser(false (0)) and
    /// implementing the do_close() callback. This is recommended for clients using
    /// non-standard close handling or windows that were not created on the browser
    /// process UI thread. 1.  User clicks the window close button which sends a
    /// close notification to
    /// the application's top-level window.
    /// 2.  Application's top-level window receives the close notification and:
    /// A. Calls CefBrowserHost::CloseBrowser(false).
    /// B. Cancels the window close.
    /// 3.  JavaScript 'onbeforeunload' handler executes and shows the close
    /// confirmation dialog (which can be overridden via
    /// CefJSDialogHandler::OnBeforeUnloadDialog()).
    /// 4.  User approves the close. 5.  JavaScript 'onunload' handler executes. 6.
    /// Application's do_close() handler is called. Application will:
    /// A. Set a flag to indicate that the next close attempt will be allowed.
    /// B. Return false.
    /// 7.  CEF sends an close notification to the application's top-level window.
    /// 8.  Application's top-level window receives the close notification and
    /// allows the window to close based on the flag from #6B.
    /// 9.  Application's top-level window is destroyed. 10. Application's
    /// on_before_close() handler is called and the browser object
    /// is destroyed.
    /// 11. Application exits by calling cef_quit_message_loop() if no other
    /// browsers
    /// exist.
    ///
    public Function<do_close> do_close = function(do_close.class);
    ///
    /// Called just before a browser is destroyed. Release all references to the
    /// browser object and do not attempt to execute any functions on the browser
    /// object after this callback returns. This callback will be the last
    /// notification that references |browser|. See do_close() documentation for
    /// additional usage information.
    ///
    public Function<on_before_close> on_before_close = function(on_before_close.class);

    public static interface on_before_popup {
      @Delegate
      int invoke(
          cef_life_span_handler_t self_,
          jnr.ffi.Pointer browser,
          jnr.ffi.Pointer frame,
          cef_string_t target_url,
          cef_string_t target_frame_name,
          cef_window_open_disposition_t target_disposition,
          int user_gesture,
          jnr.ffi.Pointer popupFeatures,
          jnr.ffi.Pointer windowInfo,
          cef_client_t client,
          jnr.ffi.Pointer settings,
          IntByReference no_javascript_access);
    }

    public static interface on_after_created {
      @Delegate
      void invoke(cef_life_span_handler_t self_, jnr.ffi.Pointer browser);
    }

    public static interface do_close {
      @Delegate
      int invoke(cef_life_span_handler_t self_, jnr.ffi.Pointer browser);
    }

    public static interface on_before_close {
      @Delegate
      void invoke(cef_life_span_handler_t self_, jnr.ffi.Pointer browser);
    }

    public cef_life_span_handler_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }
  ///
  /// Implement this structure to provide handler implementations.
  ///
  public static class cef_client_t extends Struct {
    static {
      mapTypeForClosure(cef_client_t.class);
    }
    ///
    /// Base structure.
    ///
    public cef_base_ref_counted_t base = inner(new cef_base_ref_counted_t(getRuntime()));
    ///
    /// Return the handler for context menus. If no handler is provided the default
    /// implementation will be used.
    ///
    public Function<get_context_menu_handler> get_context_menu_handler =
        function(get_context_menu_handler.class);
    ///
    /// Return the handler for dialogs. If no handler is provided the default
    /// implementation will be used.
    ///
    public Function<get_dialog_handler> get_dialog_handler = function(get_dialog_handler.class);
    ///
    /// Return the handler for browser display state events.
    ///
    public Function<get_display_handler> get_display_handler = function(get_display_handler.class);
    ///
    /// Return the handler for download events. If no handler is returned downloads
    /// will not be allowed.
    ///
    public Function<get_download_handler> get_download_handler =
        function(get_download_handler.class);
    ///
    /// Return the handler for drag events.
    ///
    public Function<get_drag_handler> get_drag_handler = function(get_drag_handler.class);
    ///
    /// Return the handler for find result events.
    ///
    public Function<get_find_handler> get_find_handler = function(get_find_handler.class);
    ///
    /// Return the handler for focus events.
    ///
    public Function<get_focus_handler> get_focus_handler = function(get_focus_handler.class);
    ///
    /// Return the handler for geolocation permissions requests. If no handler is
    /// provided geolocation access will be denied by default.
    ///
    public Function<get_geolocation_handler> get_geolocation_handler =
        function(get_geolocation_handler.class);
    ///
    /// Return the handler for JavaScript dialogs. If no handler is provided the
    /// default implementation will be used.
    ///
    public Function<get_jsdialog_handler> get_jsdialog_handler =
        function(get_jsdialog_handler.class);
    ///
    /// Return the handler for keyboard events.
    ///
    public Function<get_keyboard_handler> get_keyboard_handler =
        function(get_keyboard_handler.class);
    ///
    /// Return the handler for browser life span events.
    ///
    public Function<get_life_span_handler> get_life_span_handler =
        function(get_life_span_handler.class);
    ///
    /// Return the handler for browser load status events.
    ///
    public Function<get_load_handler> get_load_handler = function(get_load_handler.class);
    ///
    /// Return the handler for off-screen rendering events.
    ///
    public Function<get_render_handler> get_render_handler = function(get_render_handler.class);
    ///
    /// Return the handler for browser request events.
    ///
    public Function<get_request_handler> get_request_handler = function(get_request_handler.class);
    ///
    /// Called when a new message is received from a different process. Return true
    /// (1) if the message was handled or false (0) otherwise. Do not keep a
    /// reference to or attempt to access the message outside of this callback.
    ///
    public Function<on_process_message_received> on_process_message_received =
        function(on_process_message_received.class);

    public static interface get_context_menu_handler {
      @Delegate
      jnr.ffi.Pointer invoke(cef_client_t self_);
    }

    public static interface get_dialog_handler {
      @Delegate
      jnr.ffi.Pointer invoke(cef_client_t self_);
    }

    public static interface get_display_handler {
      @Delegate
      cef_display_handler_t invoke(cef_client_t self_);
    }

    public static interface get_download_handler {
      @Delegate
      jnr.ffi.Pointer invoke(cef_client_t self_);
    }

    public static interface get_drag_handler {
      @Delegate
      jnr.ffi.Pointer invoke(cef_client_t self_);
    }

    public static interface get_find_handler {
      @Delegate
      jnr.ffi.Pointer invoke(cef_client_t self_);
    }

    public static interface get_focus_handler {
      @Delegate
      cef_focus_handler_t invoke(cef_client_t self_);
    }

    public static interface get_geolocation_handler {
      @Delegate
      jnr.ffi.Pointer invoke(cef_client_t self_);
    }

    public static interface get_jsdialog_handler {
      @Delegate
      jnr.ffi.Pointer invoke(cef_client_t self_);
    }

    public static interface get_keyboard_handler {
      @Delegate
      jnr.ffi.Pointer invoke(cef_client_t self_);
    }

    public static interface get_life_span_handler {
      @Delegate
      cef_life_span_handler_t invoke(cef_client_t self_);
    }

    public static interface get_load_handler {
      @Delegate
      cef_load_handler_t invoke(cef_client_t self_);
    }

    public static interface get_render_handler {
      @Delegate
      jnr.ffi.Pointer invoke(cef_client_t self_);
    }

    public static interface get_request_handler {
      @Delegate
      jnr.ffi.Pointer invoke(cef_client_t self_);
    }

    public static interface on_process_message_received {
      @Delegate
      int invoke(
          cef_client_t self_,
          jnr.ffi.Pointer browser,
          cef_process_id_t source_process,
          jnr.ffi.Pointer message);
    }

    public cef_client_t(jnr.ffi.Runtime runtime) {
      super(runtime);
    }
  }
}
